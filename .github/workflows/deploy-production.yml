name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      deployment_target:
        description: "What to deploy"
        required: true
        default: "both"
        type: choice
        options:
          - backend
          - frontend
          - both
      confirm_production:
        description: 'Type "PRODUCTION" to confirm deployment to live site'
        required: true
        type: string

jobs:
  # Validation job to ensure proper confirmation
  validate-production-deployment:
    runs-on: ubuntu-latest
    steps:
      - name: Validate Production Deployment
        run: |
          if [ "${{ github.event.inputs.confirm_production }}" != "PRODUCTION" ]; then
            echo "‚ùå Production deployment cancelled."
            echo "   You must type 'PRODUCTION' (all caps) to confirm deployment to the live site."
            echo "   This is a safety measure to prevent accidental production deployments."
            exit 1
          fi
          echo "‚úÖ Production deployment confirmed"
          echo "üöÄ Proceeding with production deployment..."

  # Stage 1: Backend Production Deployment
  deploy-backend-production:
    runs-on: ubuntu-latest
    needs: validate-production-deployment
    if: github.event.inputs.deployment_target == 'backend' || github.event.inputs.deployment_target == 'both'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.24"
          cache: true
          cache-dependency-path: backend/go.sum

      - name: Build Production Binary
        working-directory: ./backend
        run: |
          echo "üèóÔ∏è Building production binary..."
          echo "üìÅ Working directory: $(pwd)"
          echo "üìÑ Go modules: $(ls -la go.*)"
          go mod download
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
            -ldflags="-w -s" \
            -o psychic-homily-production \
            ./cmd/server

      - name: Setup Production Infrastructure
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_VPS_HOST }}
          username: ${{ secrets.PROD_VPS_USERNAME }}
          key: ${{ secrets.PROD_VPS_SSH_KEY }}
          script: |
            # Check if directory exists and try to create without sudo first
            if [ ! -d /opt/psychic-homily-production ]; then
              # Try without sudo first
              mkdir -p /opt/psychic-homily-production 2>/dev/null || {
                echo "Need sudo access to create /opt/psychic-homily-production"
                echo "Please run on VPS: sudo usermod -aG sudo deploy"
                echo "And add to /etc/sudoers: deploy ALL=(ALL) NOPASSWD: /bin/mkdir, /bin/chown"
                exit 1
              }
            fi

      - name: Setup Production Git Repository
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_VPS_HOST }}
          username: ${{ secrets.PROD_VPS_USERNAME }}
          key: ${{ secrets.PROD_VPS_SSH_KEY }}
          script: |
            cd /opt/psychic-homily-production

            # Always ensure we have the latest code from our repository
            if [ ! -d .git ]; then
              echo "üîß First time setup: cloning production repository..."
              # Remove any existing files to ensure clean state
              rm -rf * .[^.]* 2>/dev/null || true
              git clone https://github.com/${{ github.repository }}.git .
              echo "‚úÖ Production repository cloned successfully"
            else
              echo "üîÑ Syncing production environment with latest changes..."
              # Fetch latest changes and reset to match origin/main exactly
              git fetch origin
              git reset --hard origin/main
              git clean -fd  # Remove any untracked files
              echo "‚úÖ Production environment synced with latest main branch"
            fi

      - name: Setup Production Services
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_VPS_HOST }}
          username: ${{ secrets.PROD_VPS_USERNAME }}
          key: ${{ secrets.PROD_VPS_SSH_KEY }}
          script: |
            cd /opt/psychic-homily-production

            # Make scripts executable
            chmod +x scripts/*.sh

            # Install systemd service if not exists
            if [ ! -f /etc/systemd/system/psychic-homily-production.service ]; then
              sudo cp systemd/psychic-homily-production.service /etc/systemd/system/
              sudo systemctl daemon-reload
              echo "Production systemd service installed"
            fi

      - name: Clean Previous Binary
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_VPS_HOST }}
          username: ${{ secrets.PROD_VPS_USERNAME }}
          key: ${{ secrets.PROD_VPS_SSH_KEY }}
          script: |
            cd /opt/psychic-homily-production
            rm -f psychic-homily-production
            exit 0

      - name: Upload Production Binary
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.PROD_VPS_HOST }}
          username: ${{ secrets.PROD_VPS_USERNAME }}
          key: ${{ secrets.PROD_VPS_SSH_KEY }}
          source: "backend/psychic-homily-production"
          target: "/opt/psychic-homily-production"

      - name: Deploy Production with Zero-Downtime
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_VPS_HOST }}
          username: ${{ secrets.PROD_VPS_USERNAME }}
          key: ${{ secrets.PROD_VPS_SSH_KEY }}
          script: |
            cd /opt/psychic-homily-production
            ./backend/scripts/deploy-production.sh ${{ github.sha }}

      - name: Wait for Production Backend Health
        run: |
          echo "‚è≥ Waiting for production backend to be healthy..."
          sleep 45  # Give production more time to stabilize

      - name: Verify Production Backend Health
        run: |
          echo "üè• Verifying production backend health..."

          # Retry logic for production health check
          max_attempts=10
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if curl -f --connect-timeout 10 --max-time 30 "https://api.psychichomily.com/health" > /dev/null 2>&1; then
              echo "‚úÖ Production backend is healthy!"
              break
            else
              echo "‚è≥ Backend health check attempt $((attempt + 1))/$max_attempts failed, retrying..."
              sleep 10
              ((attempt++))
            fi
          done

          if [ $attempt -eq $max_attempts ]; then
            echo "‚ùå Production backend health check failed after $max_attempts attempts"
            echo "üö® Production backend may not be responding correctly"
            exit 1
          fi

          echo "‚úÖ Production backend deployment completed successfully"

  # Stage 2: Frontend Production Deployment
  deploy-frontend-production:
    runs-on: ubuntu-latest
    needs: [validate-production-deployment, deploy-backend-production]
    if: always() && needs.validate-production-deployment.result == 'success' && (github.event.inputs.deployment_target == 'frontend' || github.event.inputs.deployment_target == 'both') && (needs.deploy-backend-production.result == 'success' || needs.deploy-backend-production.result == 'skipped')
    steps:
      - name: Wait for Backend Stabilization
        if: needs.deploy-backend-production.result == 'success'
        run: |
          echo "‚è≥ Waiting for production backend to fully stabilize..."
          sleep 60  # Give production backend time to fully stabilize

      - name: Trigger Netlify Production Build
        id: trigger_netlify_prod
        run: |
          echo "üöÄ Triggering frontend production deployment on Netlify..."
          if [ -z "$NETLIFY_PRODUCTION_WEBHOOK" ]; then
            echo "‚ùå NETLIFY_PRODUCTION_WEBHOOK secret not set"
            echo "Please add the Netlify production build hook URL to GitHub repository secrets"
            exit 1
          fi

          # Trigger build and capture response
          response=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d "{\"trigger_title\":\"Production Deploy - Commit ${{ github.sha }}\", \"trigger_branch\":\"production\"}" \
            "$NETLIFY_PRODUCTION_WEBHOOK")

          # Check if webhook succeeded
          if [ $? -eq 0 ]; then
            echo "‚úÖ Netlify production build triggered successfully"
            echo "Response: $response"
            
            # Try to extract deploy ID if available
            deploy_id=$(echo "$response" | jq -r '.id // empty' 2>/dev/null || echo "")
            if [ -n "$deploy_id" ]; then
              echo "üìù Deploy ID: $deploy_id"
              echo "deploy_id=$deploy_id" >> $GITHUB_OUTPUT
            else
              echo "deploy_id=" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Netlify production webhook request failed"
            exit 1
          fi
        env:
          NETLIFY_PRODUCTION_WEBHOOK: ${{ secrets.NETLIFY_PRODUCTION_WEBHOOK }}

      - name: Monitor Netlify Production Deploy Status
        run: |
          echo "üîç Monitoring Netlify production deployment status..."

          deploy_id="${{ steps.trigger_netlify_prod.outputs.deploy_id }}"
          max_attempts=60  # ~20 minutes with 20s intervals (increased from 50)
          attempt=0
          last_status=""
          consecutive_failures=0
          max_consecutive_failures=3

          if [ -n "$deploy_id" ] && [ -n "$NETLIFY_PROD_TOKEN" ]; then
            echo "üéØ Tracking specific production deploy: $deploy_id"
            
            # Track specific deploy by ID
            while [ $attempt -lt $max_attempts ]; do
              echo "üìä Checking production deploy status (attempt $((attempt + 1))/$max_attempts)..."
              
              deploy_info=$(curl -s -H "Authorization: Bearer $NETLIFY_PROD_TOKEN" \
                "https://api.netlify.com/api/v1/deploys/$deploy_id" 2>/dev/null)
              
              if [ $? -eq 0 ] && [ -n "$deploy_info" ]; then
                status=$(echo "$deploy_info" | jq -r '.state // "unknown"')
                context=$(echo "$deploy_info" | jq -r '.context // "unknown"')
                error_message=$(echo "$deploy_info" | jq -r '.error_message // ""')
                
                echo "  Status: $status"
                echo "  Context: $context"
                
                # Check for consecutive failures (only count actual error states)
                if [ "$status" = "$last_status" ] && [ "$status" = "error" ]; then
                  ((consecutive_failures++))
                  echo "  ‚ö†Ô∏è Consecutive failures: $consecutive_failures/$max_consecutive_failures"
                else
                  consecutive_failures=0
                fi
                
                # Exit if too many consecutive failures
                if [ $consecutive_failures -ge $max_consecutive_failures ]; then
                  echo "‚ùå Too many consecutive failures, aborting production deployment"
                  exit 1
                fi
                
                last_status="$status"
                
                case $status in
                  "ready")
                    echo "‚úÖ Netlify production deployment completed successfully!"
                    break
                    ;;
                  "error"|"failed")
                    echo "‚ùå Netlify production deployment failed!"
                    if [ -n "$error_message" ]; then
                      echo "Error: $error_message"
                    else
                      echo "No detailed error message available"
                    fi
                    exit 1
                    ;;
                  "building"|"enqueued"|"preparing"|"processing"|"starting up")
                    echo "  ‚è≥ Production deployment in progress..."
                    echo "  üìù Note: 'enqueued' can last several minutes due to infrastructure capacity"
                    echo "  üîÑ Continuing to poll for status changes..."
                    
                    # Check if we've been stuck in this state too long
                    if [ $attempt -gt 45 ] && [ "$status" = "$last_status" ]; then
                      echo "  ‚ö†Ô∏è Production deployment seems stuck in $status state for a while"
                      echo "  üîç Checking for potential issues..."
                      
                      # Try to get more details about the deploy
                      if [ -n "$deploy_id" ]; then
                        deploy_details=$(curl -s -H "Authorization: Bearer $NETLIFY_PROD_TOKEN" \
                          "https://api.netlify.com/api/v1/sites/$NETLIFY_PROD_SITE_ID/deploys/$deploy_id" 2>/dev/null)
                        
                        if [ $? -eq 0 ] && [ -n "$deploy_details" ]; then
                          deploy_ready=$(echo "$deploy_details" | jq -r '.ready // false')
                          deploy_error=$(echo "$deploy_details" | jq -r '.error_message // "none"')
                          deploy_created=$(echo "$deploy_details" | jq -r '.created_at // "unknown"')
                          
                          echo "  üîç Production deploy details:"
                          echo "    - Ready: $deploy_ready"
                          echo "    - Error: $deploy_error"
                          echo "    - Created: $deploy_created"
                          
                          # Only exit if there's an actual error message
                          if [ "$deploy_error" != "none" ] && [ "$deploy_error" != "" ]; then
                            echo "‚ùå Production deploy has error: $deploy_error"
                            exit 1
                          fi
                          
                          # If no error and still building, give it more time
                          echo "  ‚è≥ No errors detected, continuing to wait for production build completion..."
                          echo "  üìä This is normal for Netlify builds that may queue due to infrastructure capacity"
                        fi
                      fi
                    fi
                    
                    # CRITICAL: Wait and continue polling for these states
                    sleep 10
                    continue
                    ;;
                  "new")
                    echo "  üìã Production deploy built successfully but not yet published"
                    echo "  ‚ÑπÔ∏è  Production builds may require manual approval - this is normal"
                    echo "  üîç Checking if deploy should auto-publish..."
                    
                    # Check if deploy is actually ready for publishing
                    deploy_details=$(curl -s -H "Authorization: Bearer $NETLIFY_PROD_TOKEN" \
                      "https://api.netlify.com/api/v1/sites/$NETLIFY_PROD_SITE_ID/deploys/$deploy_id" 2>/dev/null)
                    
                    if [ $? -eq 0 ] && [ -n "$deploy_details" ]; then
                      deploy_state=$(echo "$deploy_details" | jq -r '.state // "unknown"')
                      deploy_ready=$(echo "$deploy_details" | jq -r '.ready // false')
                      deploy_error=$(echo "$deploy_details" | jq -r '.error_message // "none"')
                      
                      echo "  üîç Production deploy details:"
                      echo "    - State: $deploy_state"
                      echo "    - Ready: $deploy_ready"
                      echo "    - Error: $deploy_error"
                      
                      # Only exit if there's an actual error message
                      if [ "$deploy_error" != "none" ] && [ "$deploy_error" != "" ]; then
                        echo "‚ùå Production deploy has error: $deploy_error"
                        exit 1
                      fi
                      
                      # For production, we might want to require manual publish
                      # But let's check if it's ready first
                      if [ "$deploy_ready" = "true" ] || [ "$deploy_state" = "ready" ]; then
                        echo "  ‚úÖ Production deploy is ready and should auto-publish"
                        echo "  ‚è≥ Waiting for auto-publish..."
                        sleep 30
                      else
                        echo "  ‚è≥ Production deploy not quite ready yet..."
                        sleep 10
                      fi
                    else
                      echo "  ‚ö†Ô∏è Could not fetch production deploy details, waiting..."
                      sleep 10
                      continue
                    fi
                    ;;
                  *)
                    echo "  ‚ö†Ô∏è Unknown production deploy status: $status"
                    ;;
                esac
              else
                echo "  ‚ö†Ô∏è Failed to fetch production deploy status (attempt $((attempt + 1)))"
                echo "   This may be a temporary API issue. Retrying..."
                
                # Don't break immediately - retry a few times
                if [ $attempt -gt 10 ]; then
                  echo "  ‚ö†Ô∏è Multiple API failures, trying site-level check..."
                  break
                fi
                
                sleep 10  # Shorter sleep for retries
                continue
              fi
              
              if [ $attempt -eq $((max_attempts - 1)) ]; then
                echo "‚ö†Ô∏è Production deployment status check reached maximum attempts"
                echo "   The build may still be in progress. Check Netlify dashboard for status."
                echo "   Attempting site-level check as fallback..."
                
                # Don't exit 1 here - let it continue to site-level check
                # The build might still succeed even if we can't track it via specific deploy ID
                break
              fi
              
              sleep 10
              ((attempt++))
            done
            
          elif [ -n "$NETLIFY_PROD_TOKEN" ] && [ -n "$NETLIFY_PROD_SITE_ID" ]; then
            echo "üîç Checking production site-level deployment status..."
            
            # Initialize last_status for production site-level tracking
            last_status=""
            
            # Method 2: Check latest deploy for the production site
            while [ $attempt -lt $max_attempts ]; do
              echo "üìä Checking latest production deploy (attempt $((attempt + 1))/$max_attempts)..."
              
              site_deploys=$(curl -s -H "Authorization: Bearer $NETLIFY_PROD_TOKEN" \
                "https://api.netlify.com/api/v1/sites/$NETLIFY_PROD_SITE_ID/deploys?per_page=1" 2>/dev/null)
              
              if [ $? -eq 0 ] && [ -n "$site_deploys" ]; then
                latest_deploy=$(echo "$site_deploys" | jq -r '.[0]')
                status=$(echo "$latest_deploy" | jq -r '.state // "unknown"')
                deploy_id=$(echo "$latest_deploy" | jq -r '.id // ""')
                commit_sha=$(echo "$latest_deploy" | jq -r '.commit_sha // ""')
                error_message=$(echo "$latest_deploy" | jq -r '.error_message // ""')
                
                echo "  Status: $status"
                echo "  Commit: ${commit_sha:0:8}"
                
                # Track status changes for stuck detection
                if [ "$status" = "$last_status" ]; then
                  echo "  üìä Status unchanged: $status (attempt $attempt)"
                else
                  echo "  üîÑ Status changed: $last_status ‚Üí $status"
                  last_status="$status"
                fi
                
                # Only exit if there's an actual error message
                if [ -n "$error_message" ] && [ "$error_message" != "" ]; then
                  echo "‚ùå Latest production deployment has error: $error_message"
                  exit 1
                fi
                
                case $status in
                  "ready")
                    echo "‚úÖ Latest production deployment is ready!"
                    break
                    ;;
                  "new")
                    echo "  üìã Production deploy built and ready"
                    echo "  ‚ÑπÔ∏è  Production may require manual publish - this is expected"
                    break
                    ;;
                  "error"|"failed")
                    echo "‚ùå Latest production deployment failed!"
                    exit 1
                    ;;
                  "building"|"enqueued"|"preparing"|"processing"|"starting up")
                    echo "  ‚è≥ Production deployment in progress..."
                    echo "  üìù Note: 'enqueued' can last several minutes due to infrastructure capacity"
                    ;;
                esac
              else
                echo "  ‚ö†Ô∏è Failed to fetch production site deploys (attempt $((attempt + 1)))"
                echo "   This may be a temporary API issue. Retrying..."
                
                # Don't break immediately - retry a few times
                if [ $attempt -gt 10 ]; then
                  echo "  ‚ö†Ô∏è Multiple API failures, trying health check method..."
                  break
                fi
                
                sleep 10  # Shorter sleep for retries
                continue
              fi
              
              if [ $attempt -eq $((max_attempts - 1)) ]; then
                echo "‚ö†Ô∏è Production site-level deployment check reached maximum attempts"
                echo "   The build may still be in progress. Check Netlify dashboard for status."
                echo "   Attempting health check method as final fallback..."
                
                # Don't exit 1 here - let it continue to health check method
                break
              fi
              
              sleep 20
              ((attempt++))
            done
          else
            echo "‚ö†Ô∏è No Netlify production API access or all API methods failed - using health check method..."
            echo "   This is the final fallback when API tracking cannot be used"
            
            # Method 3: Fallback to health checks
            # Give Netlify more time to actually complete the build and deploy
            echo "‚è≥ Waiting for Netlify production build to complete before health checks..."
            sleep 180  # Wait 3 minutes for production build to complete (longer than stage)
            
            while [ $attempt -lt $max_attempts ]; do
              echo "üîç Production health check (attempt $((attempt + 1))/$max_attempts)..."
              
              if curl -f -s -H "Cache-Control: no-cache" \
                -H "User-Agent: GitHub-Actions-Deploy-Check" \
                "https://www.psychichomily.com/" > /dev/null 2>&1; then
                echo "  ‚úÖ Production frontend is responding!"
                
                # Wait a reasonable amount before declaring success
                if [ $attempt -gt 3 ]; then
                  echo "‚úÖ Production frontend deployment appears successful!"
                  break
                fi
              else
                echo "  ‚ö†Ô∏è Production frontend not responding yet..."
              fi
              
              if [ $attempt -eq $((max_attempts - 1)) ]; then
                echo "‚ùå Production frontend health check timed out"
                echo "   The Netlify build may still be in progress or there may be an issue"
                echo "   Check the Netlify dashboard for deployment status"
                exit 1
              fi
              
              sleep 10
              ((attempt++))
            done
          fi
        env:
          NETLIFY_PROD_TOKEN: ${{ secrets.NETLIFY_PROD_TOKEN }}
          NETLIFY_PROD_SITE_ID: ${{ secrets.NETLIFY_PROD_SITE_ID }}

      - name: Verify Production Frontend Deployment
        run: |
          echo "üåê Final production frontend verification..."

          # Test the actual production frontend URL
          max_attempts=5
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if curl -f -s -H "Cache-Control: no-cache" "https://www.psychichomily.com/" > /dev/null; then
              echo "‚úÖ Production frontend is accessible and responding!"
              
              # Optional: Check for specific content to verify it's updated
              response=$(curl -s "https://www.psychichomily.com/" | head -20)
              if echo "$response" | grep -q "html\|HTML" 2>/dev/null; then
                echo "‚úÖ Production frontend content looks valid!"
              else
                echo "‚ö†Ô∏è Production frontend responding but content may be incomplete"
              fi
              break
            else
              echo "‚è≥ Production frontend verification attempt $((attempt + 1))/$max_attempts..."
              sleep 30
              ((attempt++))
            fi
          done

          if [ $attempt -eq $max_attempts ]; then
            echo "‚ö†Ô∏è Production frontend verification inconclusive"
            echo "   This may be normal if the deployment requires manual approval in Netlify"
            echo "   Please check the Netlify dashboard to complete deployment if needed"
          else
            echo "‚úÖ Production frontend deployment completed successfully"
          fi

      - name: Send Production Deployment Notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéâ Production deployment completed successfully!"
            echo "üì± Backend: https://api.psychichomily.com/health"
            echo "üåê Frontend: https://www.psychichomily.com"
            echo "üìä Deployment target: ${{ github.event.inputs.deployment_target }}"
            
            # Optional: Send to Slack if webhook is configured
            if [ -n "$SLACK_WEBHOOK" ]; then
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"üöÄ PRODUCTION DEPLOYMENT SUCCESSFUL! üöÄ\n‚Ä¢ Backend: https://api.psychichomily.com/health\n‚Ä¢ Frontend: https://www.psychichomily.com\n‚Ä¢ Target: ${{ github.event.inputs.deployment_target }}\n‚Ä¢ Commit: ${{ github.sha }}\n‚Ä¢ Deployed by: ${{ github.actor }}"}' \
                "$SLACK_WEBHOOK" 2>/dev/null || echo "Slack notification failed"
            fi
          else
            echo "‚ùå Production deployment failed"
            echo "üö® PRODUCTION DEPLOYMENT FAILURE - IMMEDIATE ATTENTION REQUIRED"
            
            # Optional: Send failure notification to Slack
            if [ -n "$SLACK_WEBHOOK" ]; then
              curl -X POST -H 'Content-type: application/json' \
                --data '{"text":"üö® PRODUCTION DEPLOYMENT FAILED! üö®\n‚Ä¢ Target: ${{ github.event.inputs.deployment_target }}\n‚Ä¢ Commit: ${{ github.sha }}\n‚Ä¢ Deployed by: ${{ github.actor }}\n‚Ä¢ Check GitHub Actions immediately for details"}' \
                "$SLACK_WEBHOOK" 2>/dev/null || echo "Slack notification failed"
            fi
          fi
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
